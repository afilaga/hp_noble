import os
import logging
from datetime import datetime, timedelta
from dotenv import load_dotenv
from telegram import (
    Update,
    ReplyKeyboardMarkup,
    KeyboardButton,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)
from typing import Optional

# –ó–∞–≥—Ä—É–∑–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏–∑ .env
load_dotenv()

logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO,
)
logger = logging.getLogger(__name__)

from database import (
    ReservationRepository,
    TableRepository,
    CustomerRepository,
    ReservationStatus,
    TableStatus,
)

TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")

NAME, PHONE, DATE, TIME, PARTY_SIZE, TABLE, CONFIRMATION, CANCEL_RESERVATION, ADMIN = (
    range(9)
)

ADMIN_IDS = os.getenv("ADMIN_IDS", "").split(",")

MENU_KEYBOARD = ReplyKeyboardMarkup(
    [
        ["üìÖ –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å", "üìã –ú–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"],
        ["üçΩÔ∏è –°–≤–æ–±–æ–¥–Ω—ã–µ —Å—Ç–æ–ª—ã", "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞"],
        ["‚ùå –û—Ç–º–µ–Ω–∞"],
    ],
    resize_keyboard=True,
)


def is_admin(user_id: str) -> bool:
    return user_id in ADMIN_IDS or user_id == "test"


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    welcome = f"""
üçΩÔ∏è *–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ Central Bistro, {user.first_name}!*

–Ø –ø–æ–º–æ–≥—É –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–æ–ª–∏–∫ –≤ –Ω–∞—à–µ–º —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ.

üìÖ /book ‚Äî –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–æ–ª–∏–∫
üìã /my ‚Äî –ú–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è  
üçΩÔ∏è /tables ‚Äî –°–≤–æ–±–æ–¥–Ω—ã–µ —Å—Ç–æ–ª—ã
‚ùå /cancel ‚Äî –û—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω—å

‚ÑπÔ∏è /help ‚Äî –ü–æ–º–æ—â—å
"""

    if is_admin(str(user.id)):
        welcome += "\nüë®‚Äçüíº *–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å:*\n/admin ‚Äî –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ"

    await update.message.reply_text(
        welcome, parse_mode="Markdown", reply_markup=MENU_KEYBOARD
    )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = """
üìã *–ü–æ–º–æ—â—å –ø–æ –±–æ—Ç—É*

**–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ:**
1. –í–≤–µ–¥–∏—Ç–µ /book –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É
2. –í–≤–µ–¥–∏—Ç–µ –≤–∞—à–µ –∏–º—è
3. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω
4. –í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –∏–∑ –∫–∞–ª–µ–Ω–¥–∞—Ä—è
5. –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è
6. –£–∫–∞–∂–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≥–æ—Å—Ç–µ–π
7. –í—ã–±–µ—Ä–∏—Ç–µ —Å—Ç–æ–ª–∏–∫
8. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –±—Ä–æ–Ω—å

**–ö–æ–º–∞–Ω–¥—ã:**
‚Ä¢ /book ‚Äî –Ω–æ–≤–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
‚Ä¢ /my ‚Äî –º–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è
‚Ä¢ /cancel ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω—å
‚Ä¢ /tables ‚Äî —Å–≤–æ–±–æ–¥–Ω—ã–µ —Å—Ç–æ–ª—ã
‚Ä¢ /available 15.01 ‚Äî –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –Ω–∞ –¥–∞—Ç—É
‚Ä¢ /help ‚Äî —ç—Ç–æ —Å–æ–æ–±—â–µ–Ω–∏–µ
"""
    await update.message.reply_text(
        help_text, parse_mode="Markdown", reply_markup=MENU_KEYBOARD
    )


async def book(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    context.user_data["step"] = "name"

    await update.message.reply_text(
        "üìù *–ù–æ–≤–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ*\n\n–ö–∞–∫ –≤–∞—Å –∑–æ–≤—É—Ç?",
        parse_mode="Markdown",
        reply_markup=ReplyKeyboardMarkup([["–û—Ç–º–µ–Ω–∞"]], resize_keyboard=True),
    )
    return NAME


async def get_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    name = update.message.text.strip()
    if name.lower() == "–æ—Ç–º–µ–Ω–∞":
        return await cancel_flow(update, context)
    if len(name) < 2:
        await update.message.reply_text("–ò–º—è —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–æ–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â—ë —Ä–∞–∑:")
        return NAME

    context.user_data["name"] = name
    context.user_data["step"] = "phone"

    await update.message.reply_text(
        "üì± –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Ç–µ–ª–µ—Ñ–æ–Ω–∞:",
        reply_markup=ReplyKeyboardMarkup([["–û—Ç–º–µ–Ω–∞"]], resize_keyboard=True),
    )
    return PHONE


async def get_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    phone = update.message.text.strip()
    if phone.lower() == "–æ—Ç–º–µ–Ω–∞":
        return await cancel_flow(update, context)

    context.user_data["phone"] = phone
    context.user_data["telegram_id"] = str(update.effective_user.id)
    context.user_data["step"] = "date"

    dates = []
    today = datetime.now()
    for i in range(1, 15):
        date = today + timedelta(days=i)
        dates.append(
            [
                InlineKeyboardButton(
                    date.strftime("%d.%m (%a)"),
                    callback_data=f"date_{date.strftime('%Y-%m-%d')}",
                )
            ]
        )

    await update.message.reply_text(
        "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É:",
        reply_markup=InlineKeyboardMarkup(
            dates + [[InlineKeyboardButton("–û—Ç–º–µ–Ω–∞", callback_data="cancel")]]
        ),
    )
    return DATE


async def date_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "cancel":
        return await cancel_flow(update, context)

    context.user_data["date"] = query.data
    context.user_data["step"] = "time"

    times = []
    for hour in range(11, 23):
        for minute in ["00", "30"]:
            times.append(
                [
                    InlineKeyboardButton(
                        f"{hour}:{minute}", callback_data=f"time_{hour}:{minute}"
                    )
                ]
            )

    await query.edit_message_text(
        f"üïê –í—ã–±–µ—Ä–∏—Ç–µ –≤—Ä–µ–º—è ({query.data}):",
        reply_markup=InlineKeyboardMarkup(
            times + [[InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥", callback_data="back_date")]]
        ),
    )
    return TIME


async def time_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "back_date":
        return await get_phone(update.message, context)

    context.user_data["time"] = query.data
    context.user_data["step"] = "party_size"

    party = []
    for size in range(1, 9):
        party.append(
            [
                InlineKeyboardButton(
                    f"{size} {guest_word(size)}", callback_data=f"party_{size}"
                )
            ]
        )

    await query.edit_message_text(
        "üë• –°–∫–æ–ª—å–∫–æ –≥–æ—Å—Ç–µ–π?", reply_markup=InlineKeyboardMarkup(party)
    )
    return PARTY_SIZE


def guest_word(n: int) -> str:
    if n == 1:
        return "–≥–æ—Å—Ç—å"
    elif 2 <= n <= 4:
        return "–≥–æ—Å—Ç—è"
    return "–≥–æ—Å—Ç–µ–π"


async def party_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    party_size = int(query.data.split("_")[1])
    context.user_data["party_size"] = party_size

    date_str = context.user_data["date"]
    time_str = context.user_data["time"]
    hour, minute = map(int, time_str.split(":"))
    start_time = datetime.strptime(date_str, "%Y-%m-%d").replace(
        hour=hour, minute=minute, second=0, microsecond=0
    )
    end_time = start_time + timedelta(minutes=90)
    context.user_data["start_time"] = start_time.isoformat()

    available = TableRepository.get_available(party_size, start_time, end_time)

    if not available:
        await query.edit_message_text(
            "üòî –ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å—Ç–æ–ª–∏–∫–æ–≤ –Ω–∞ —ç—Ç–æ –≤—Ä–µ–º—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –¥—Ä—É–≥–æ–µ.",
            reply_markup=InlineKeyboardMarkup(
                [[InlineKeyboardButton("‚Üê –ö –≤—ã–±–æ—Ä—É –¥–∞—Ç—ã", callback_data="back_date")]]
            ),
        )
        return DATE

    context.user_data["available_tables"] = [t["id"] for t in available]

    tables = []
    for t in available:
        tables.append(
            [
                InlineKeyboardButton(
                    f"–°—Ç–æ–ª #{t['number']} ‚Äî {t['capacity']} —á–µ–ª. ({t['location']})",
                    callback_data=f"table_{t['id']}",
                )
            ]
        )

    await query.edit_message_text(
        f"üçΩÔ∏è –î–æ—Å—Ç—É–ø–Ω—ã–µ —Å—Ç–æ–ª–∏–∫–∏ –Ω–∞ {date_str} –≤ {time_str}:",
        reply_markup=InlineKeyboardMarkup(tables),
    )
    return TABLE


async def table_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "back_date":
        return await time_selection(update, context)

    table_id = query.data.split("_")[1]
    table = TableRepository.get(table_id)
    context.user_data["table_id"] = table_id

    name = context.user_data["name"]
    phone = context.user_data["phone"]
    party_size = context.user_data["party_size"]
    start = context.user_data["start_time"]

    summary = f"""
üìã *–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ:*

üë§ {name}
üì± {phone}
üìÖ {start[:10]}
üïê {start[11:16]}
üë• {party_size} {guest_word(party_size)}
üçΩÔ∏è –°—Ç–æ–ª #{table["number"]} ({table["location"]})

_–ù–∞–∂–º–∏—Ç–µ –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è_
"""
    await query.edit_message_text(
        summary,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(
            [
                [InlineKeyboardButton("‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å", callback_data="confirm")],
                [InlineKeyboardButton("‚Üê –ù–∞–∑–∞–¥", callback_data="back_table")],
            ]
        ),
    )
    return CONFIRMATION


async def confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "back_table":
        table_id = context.user_data["available_tables"][0]
        return await table_selection(update, context)

    if query.data != "confirm":
        return await cancel_flow(update, context)

    name = context.user_data["name"]
    phone = context.user_data["phone"]
    table_id = context.user_data["table_id"]
    start_time = datetime.fromisoformat(context.user_data["start_time"])
    party_size = context.user_data["party_size"]

    customer = CustomerRepository.get_or_create(
        name, phone, context.user_data.get("telegram_id")
    )
    customer_id = customer["id"]

    try:
        res_id = ReservationRepository.create(
            customer_id=customer_id,
            table_id=table_id,
            start_time=start_time,
            party_size=party_size,
            source="telegram",
        )

        table = TableRepository.get(table_id)
        success = f"""
‚úÖ *–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ!*

üìÖ {start_time.strftime("%d.%m.%Y")} –≤ {start_time.strftime("%H:%M")}
üçΩÔ∏è –°—Ç–æ–ª #{table["number"]} ({table["location"]})
üë• {party_size} {guest_word(party_size)}

üìù –ù–æ–º–µ—Ä –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è: `{res_id}`

–°–æ—Ö—Ä–∞–Ω–∏—Ç–µ —ç—Ç–æ—Ç –Ω–æ–º–µ—Ä –¥–ª—è –æ—Ç–º–µ–Ω—ã.
        """
        await query.edit_message_text(
            success, parse_mode="Markdown", reply_markup=MENU_KEYBOARD
        )

    except Exception as e:
        await query.edit_message_text(
            f"‚ùå –û—à–∏–±–∫–∞: {str(e)}", reply_markup=MENU_KEYBOARD
        )

    context.user_data.clear()
    return ConversationHandler.END


async def my_reservations(update: Update, context: ContextTypes.DEFAULT_TYPE):
    name = context.user_data.get("last_name")
    phone = context.args[0] if context.args else None

    if not phone:
        await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–ª–µ—Ñ–æ–Ω: /my 79991234567", reply_markup=MENU_KEYBOARD
        )
        return

    customer = CustomerRepository.get_by_phone(phone)
    if not customer:
        await update.message.reply_text(
            "–ö–ª–∏–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–æ–º–µ—Ä.", reply_markup=MENU_KEYBOARD
        )
        return

    reservations = ReservationRepository.get_by_customer(customer["id"])
    active = [
        r for r in reservations if r["status"] in ["pending", "confirmed", "seated"]
    ]

    if not active:
        await update.message.reply_text(
            "–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π.", reply_markup=MENU_KEYBOARD
        )
        return

    text = "üìã *–í–∞—à–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:*\n\n"
    for r in active[:5]:
        emoji = {"pending": "‚è≥", "confirmed": "‚úÖ", "seated": "üçΩÔ∏è"}.get(
            r["status"], "üìç"
        )
        text += f"{emoji} *{r['start_time'][:16]}*\n"
        text += f"   –°—Ç–æ–ª #{r['table_number']} ‚Äî {r['party_size']} —á–µ–ª.\n"
        text += f"   ID: `{r['id']}`\n\n"

    await update.message.reply_text(
        text, parse_mode="Markdown", reply_markup=MENU_KEYBOARD
    )


async def show_tables(update: Update, context: ContextTypes.DEFAULT_TYPE):
    tables = TableRepository.get_all()
    available = [t for t in tables if t["status"] == "available"]

    text = "üçΩÔ∏è *–°—Ç–æ–ª–∏–∫–∏ Central Bistro:*\n\n"
    text += "üü¢ *–°–≤–æ–±–æ–¥–Ω—ã–µ:*\n"
    for t in available:
        text += f"   ‚Ä¢ #{t['number']} ‚Äî {t['capacity']} —á–µ–ª. ({t['location']})\n"

    occupied = [t for t in tables if t["status"] == "occupied"]
    if occupied:
        text += "\nüî¥ *–ó–∞–Ω—è—Ç—ã–µ:*\n"
        for t in occupied:
            text += f"   ‚Ä¢ #{t['number']} ‚Äî {t['capacity']} —á–µ–ª.\n"

    await update.message.reply_text(
        text, parse_mode="Markdown", reply_markup=MENU_KEYBOARD
    )


async def check_availability(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if context.args:
        try:
            date = datetime.strptime(context.args[0], "%d.%m")
            year = datetime.now().year
            date = date.replace(year=year)
        except ValueError:
            await update.message.reply_text("–§–æ—Ä–º–∞—Ç: /available 15.01")
            return
    else:
        date = datetime.now()

    start = date
    end = date + timedelta(days=1)
    reservations = ReservationRepository.get_by_date_range(start, end)

    text = f"üìÖ *–ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞ {date.strftime('%d.%m.%Y')}:*\n\n"
    if reservations:
        for r in reservations:
            emoji = {
                "pending": "‚è≥",
                "confirmed": "‚úÖ",
                "seated": "üçΩÔ∏è",
                "completed": "‚úì",
            }.get(r["status"], "üìç")
            text += f"{emoji} {r['start_time'][11:16]} ‚Äî –°—Ç–æ–ª #{r['table_number']} ‚Äî {r['customer_name']} ({r['party_size']} —á–µ–ª.)\n"
    else:
        text += "–ù–µ—Ç –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π."

    await update.message.reply_text(
        text, parse_mode="Markdown", reply_markup=MENU_KEYBOARD
    )


async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã:",
        reply_markup=ReplyKeyboardMarkup([["–û—Ç–º–µ–Ω–∞"]], resize_keyboard=True),
    )
    return CANCEL_RESERVATION


async def process_cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    res_id = update.message.text.strip()

    if res_id.lower() == "–æ—Ç–º–µ–Ω–∞":
        await update.message.reply_text("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD)
        return ConversationHandler.END

    res = ReservationRepository.get(res_id)
    if res:
        ReservationRepository.update_status(res_id, "cancelled")
        await update.message.reply_text(
            f"‚úÖ –ë—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ {res_id} –æ—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=MENU_KEYBOARD
        )
    else:
        await update.message.reply_text(
            "–ù–µ –Ω–∞–π–¥–µ–Ω–æ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:",
            reply_markup=ReplyKeyboardMarkup([["–û—Ç–º–µ–Ω–∞"]], resize_keyboard=True),
        )
        return CANCEL_RESERVATION

    return ConversationHandler.END


async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    if not is_admin(user_id):
        await update.message.reply_text("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.")
        return

    stats = ReservationRepository.get_stats()
    today = ReservationRepository.get_today()
    upcoming = ReservationRepository.get_upcoming(5)

    text = f"""
üë®‚Äçüíº *–ü–∞–Ω–µ–ª—å –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞*

üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*
‚Ä¢ –í—Å–µ–≥–æ: {stats["total"]}
‚Ä¢ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ: {stats["confirmed"]}
‚Ä¢ –ó–∞–≤–µ—Ä—à–µ–Ω–æ: {stats["completed"]}
‚Ä¢ –û—Ç–º–µ–Ω–µ–Ω–æ: {stats["cancelled"]}
‚Ä¢ –ü—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: {stats["completion_rate"]}%

üìÖ *–°–µ–≥–æ–¥–Ω—è:* {len(today)} –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π

‚è∞ *–°–∫–æ—Ä–æ:*
"""
    for r in upcoming:
        text += f"‚Ä¢ {r['start_time'][:16]} ‚Äî {r['customer_name']} (–°—Ç–æ–ª #{r['table_number']})\n"

    text += "\nüõ† *–ö–æ–º–∞–Ω–¥—ã:*\n"
    text += "/tables ‚Äî —Å–ø–∏—Å–æ–∫ —Å—Ç–æ–ª–æ–≤\n"
    text += "/reservations ‚Äî –≤—Å–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è\n"
    text += "/confirm <id> ‚Äî –ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å\n"
    text += "/seat <id> ‚Äî —Ä–∞–∑–º–µ—Å—Ç–∏—Ç—å\n"
    text += "/complete <id> ‚Äî –∑–∞–≤–µ—Ä—à–∏—Ç—å\n"
    text += "/cancel <id> ‚Äî –æ—Ç–º–µ–Ω–∏—Ç—å\n"

    await update.message.reply_text(text, parse_mode="Markdown")


async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    if not is_admin(user_id):
        return

    cmd = context.args

    if not cmd or cmd[0] == "stats":
        return await admin_panel(update, context)

    action = cmd[0]

    if action == "tables":
        return await show_tables(update, context)

    if action == "reservations":
        reservations = ReservationRepository.get_upcoming(20)
        text = "üìã *–í—Å–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è:*\n\n"
        for r in reservations:
            emoji = {"pending": "‚è≥", "confirmed": "‚úÖ", "seated": "üçΩÔ∏è"}.get(
                r["status"], "üìç"
            )
            text += f"{emoji} `{r['id']}` | {r['start_time'][:16]} | {r['customer_name']} | –°—Ç–æ–ª #{r['table_number']}\n"
        await update.message.reply_text(text, parse_mode="Markdown")
        return

    if len(cmd) < 2:
        await update.message.reply_text(f"–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /admin {action} <id>")
        return

    res_id = cmd[1]
    reason = " ".join(cmd[2:]) if len(cmd) > 2 else ""

    actions = {
        "confirm": ("confirmed", "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–æ"),
        "seat": ("seated", "üçΩÔ∏è –ì–æ—Å—Ç–∏ —Ä–∞–∑–º–µ—â–µ–Ω—ã"),
        "complete": ("completed", "‚úì –ó–∞–≤–µ—Ä—à–µ–Ω–æ"),
        "cancel": ("cancelled", f"‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ: {reason}"),
    }

    if action in actions:
        status, msg = actions[action]
        ReservationRepository.update_status(res_id, status)
        await update.message.reply_text(msg)
    else:
        await update.message.reply_text(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞: {action}")


async def cancel_flow(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data.clear()
    msg = update.message or update.callback_query.message
    await msg.edit_text("‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=None)
    return ConversationHandler.END


async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = update.message.text

    if text in ["üìÖ –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å", "/book"]:
        return await book(update, context)
    elif text in ["üìã –ú–æ–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è", "/my"]:
        return await my_reservations(update, context)
    elif text in ["üçΩÔ∏è –°–≤–æ–±–æ–¥–Ω—ã–µ —Å—Ç–æ–ª—ã", "/tables"]:
        return await show_tables(update, context)
    elif text in ["‚ùå –û—Ç–º–µ–Ω–∞", "–û—Ç–º–µ–Ω–∞"]:
        return await cancel_flow(update, context)
    elif text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞":
        stats = ReservationRepository.get_stats()
        await update.message.reply_text(
            f"üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:*\n\n–í—Å–µ–≥–æ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π: {stats['total']}\n–ó–∞–≤–µ—Ä—à–µ–Ω–æ: {stats['completed']}\n–û—Ç–º–µ–Ω–µ–Ω–æ: {stats['cancelled']}\n–ü—Ä–æ—Ü–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: {stats['completion_rate']}%",
            parse_mode="Markdown",
        )


def main():
    application = Application.builder().token(TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("book", book),
            MessageHandler(filters.TEXT & filters.Regex("üìÖ –ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å"), book),
        ],
        states={
            NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_name)],
            PHONE: [MessageHandler(filters.TEXT & ~filters.COMMAND, get_phone)],
            DATE: [CallbackQueryHandler(date_selection)],
            TIME: [CallbackQueryHandler(time_selection)],
            PARTY_SIZE: [CallbackQueryHandler(party_selection)],
            TABLE: [CallbackQueryHandler(table_selection)],
            CONFIRMATION: [CallbackQueryHandler(confirmation)],
        },
        fallbacks=[MessageHandler(filters.TEXT & filters.Regex("–û—Ç–º–µ–Ω–∞"), cancel_flow)],
    )

    cancel_conv = ConversationHandler(
        entry_points=[CommandHandler("cancel", cancel_command)],
        states={
            CANCEL_RESERVATION: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, process_cancel)
            ]
        },
        fallbacks=[MessageHandler(filters.TEXT & filters.Regex("–û—Ç–º–µ–Ω–∞"), cancel_flow)],
    )

    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(CommandHandler("my", my_reservations))
    application.add_handler(CommandHandler("tables", show_tables))
    application.add_handler(CommandHandler("available", check_availability))
    application.add_handler(CommandHandler("admin", admin_command))
    application.add_handler(conv_handler)
    application.add_handler(cancel_conv)
    application.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text)
    )

    application.run_polling()


if __name__ == "__main__":
    main()
